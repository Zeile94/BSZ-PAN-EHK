<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>CWE – Mitarbeiterchat</title>
<style>
:root {
  --bg: #121212;
  --surface: #1E1E1E;
  --surface-light: #2A2A2A;
  --text: #EAEAEA;
  --text-dim: #A8A8A8;
  --accent: #6264A7;
  --action: #6264A7; /* einheitliche Aktionsfarbe (Senden-Icon, Zurück-Button) */
  --bubble-user: var(--action);
  --bubble-bot: #2A2A2A;
  --border: #333;
  --desc-gray: #888;
  --teams-blue: #6264A7;
  --app-header-height: 70px;
  --composer-height: 65px;
}
* {
  box-sizing: border-box;
}
html, body {
  width: 100%;
  height: 100%;
  overflow: hidden;
  touch-action: manipulation;
}
body {
  margin: 0;
  background: var(--bg);
  color: var(--text);
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  display: flex;
  justify-content: center;
  align-items: stretch;
  font-size: 17px; /* global +1 */
  overscroll-behavior: none; /* verhindert Browsertab/Seiten-Scrollsprünge */
}
/* Geräteraum */
.phone {
  width: 100%;
  max-width: 600px;
  height: 100dvh; /* dynamic viewport height verhindert Sprünge bei Tastatur */
  min-height: 100%; /* Fallback */
  display: flex;
  flex-direction: column;
  overflow: hidden;
  position: relative;
}

/* Statischer App-Header (bleibt beim Übergang unverändert) */
.app-header {
  background: white;
  height: var(--app-header-height);
  padding: 0 18px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 18px; /* +1 */
  font-weight: 600;
  border-bottom: 1px solid var(--border);
  position: sticky; /* reicht hier, da der Inhalt darunter scrollt */
  top: 0;
  z-index: 100; /* über bewegten Ansichten */
  color: #000000;
  user-select: none;
  flex-shrink: 0;
}
.app-header .ms-logo {
  position: absolute;
  left: 18px;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
}
.app-header .ms-logo img {
  max-width: 100%;
  max-height: 100%;
}
.app-header .logo {
  position: absolute;
  right: 18px;
  height: 40px;
}
.app-header .logo img {
  height: 40px;
  width: auto;
}

/* Animierte Bereiche liegen unterhalb des statischen Headers */
#chatList, #chatWindow {
  position: absolute;
  left: 0; right: 0;
  top: var(--app-header-height); /* unter Header beginnen */
  bottom: 0;
  transition: transform 0.35s ease, opacity 0.35s ease;
  will-change: transform, opacity;
  background: var(--surface);
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  -webkit-overflow-scrolling: touch;
}

/* Sichtbarkeit der Chatliste */
#chatList.visible {
  opacity: 1;
  pointer-events: auto;
  transform: translateX(0);
  z-index: 40;
}
#chatList.hidden {
  opacity: 0;
  pointer-events: none;
  transform: translateX(-100%);
  z-index: 0;
}

/* Sichtbarkeit des Chatfensters */
#chatWindow.visible {
  opacity: 1;
  pointer-events: auto;
  transform: translateX(0);
  z-index: 50;
  display: flex;
}
#chatWindow.hidden {
  opacity: 0;
  pointer-events: none;
  transform: translateX(100%);
  z-index: 0;
  display: flex;
}

/* Chatliste Items */
#chatList {
  background: var(--surface);
}
.chat-item {
  display: flex;
  align-items: center;
  padding: 12px;
  gap: 12px;
  border-bottom: 1px solid var(--border);
  cursor: pointer;
}
.chat-item:hover {
  background: #2b2b2b;
}
.chat-item img {
  width: 52px;
  height: 52px;
  border-radius: 50%;
  object-fit: cover;
  background: var(--surface-light);
}
.chat-item .info .name {
  font-size: 16px; /* +1 */
  font-weight: 600;
}
.chat-item .info .role {
  font-size: 14px; /* +1 */
  color: var(--text-dim);
}

/* Beschreibung unter Chat-Header im Chatfenster */
.desc {
  background: var(--surface);
  color: var(--desc-gray);
  font-size: 14px; /* +1 */
  line-height: 1.4;
  margin: 10px 14px;
  padding: 8px;
  border-radius: 8px;
  white-space: pre-wrap;
  word-break: break-word;
}

/* Chatfenster Inhalte */
#chatWindow {
  flex-direction: column;
  overflow: hidden;
}

/* Chat-Header im Chatfenster (unter dem statischen App-Header) */
.chat-header {
  background: var(--surface-light);
  display: flex;
  align-items: center;
  padding: 10px 14px;
  border-bottom: 1px solid var(--border);
  position: relative;
  top: auto;
  z-index: 1;
  flex-shrink: 0;
}
.back-btn {
  font-size: 23px; /* +1 */
  cursor: pointer;
  color: var(--action);
  margin-right: 15px;
  user-select: none;
}
.chat-header img {
  width: 42px;
  height: 42px;
  border-radius: 50%;
  object-fit: cover;
  background: var(--surface-light);
  margin-right: 15px;
}
.chat-header .name {
  font-size: 16px; /* +1 */
  font-weight: 600;
}

/* Nachrichtenbereich */
.messages {
  flex: 1 1 auto;
  overflow-y: auto;
  padding: 10px 14px;
  display: flex;
  flex-direction: column;
  gap: 10px;
  scrollbar-width: thin;
  scrollbar-color: var(--accent) transparent;
  scroll-behavior: smooth;
  -webkit-overflow-scrolling: touch;
  overscroll-behavior: contain; /* verhindert Scroll-Propagation nach außen */
  /* Standard reserve: composer height + margin */
  padding-bottom: calc(var(--composer-height) + 12px);
}
.msg {
  max-width: 75%;
  padding: 10px 14px;
  border-radius: 14px;
  font-size: 15px; /* +1 */
  line-height: 1.4;
  white-space: pre-wrap;
  word-break: break-word;
  color: var(--text);
}
.msg.user {
  background: var(--bubble-user);
  align-self: flex-end;
}
.msg.bot {
  background: var(--bubble-bot);
  border: 1px solid var(--border);
  align-self: flex-start;
}

/* WICHTIG: Inhalte während des Übergangs unsichtbar halten (keine Verzerrung sichtbar) */
#chatWindow.content-building .desc,
#chatWindow.content-building .messages {
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.15s ease; /* leichtes Einblenden nachdem die Slide-Transition fertig ist */
}

/* Composer: fixed + overlay behavior */
.composer {
  background: var(--surface);
  border: none;
  padding: 8px 0;
  display: flex;
  gap: 8px;
  align-items: flex-end;
  flex-shrink: 0;
  position: fixed;
  left: 0;
  right: 0;
  bottom: 0;
  height: var(--composer-height);
  transform: translateY(0);
  transition: transform 0.18s ease-out;
  z-index: 999;
  max-width: 600px;
  margin: 0 auto;
}
.composer-inner {
  display: flex;
  align-items: flex-end;
  gap: 8px;
  width: 100%;
  padding-left: 30px;  /* links 14px Abstand */
  padding-right: 20px; /* rechts 14px Abstand */
  box-sizing: border-box;
}
.composer textarea {
  flex: 1;
  min-height: 40px;
  max-height: 140px;
  background: var(--surface);
  color: var(--text);
  border: 0.7px solid white;
  border-radius: 10px;
  padding: 8px 20px 8px 20px;
  resize: none;
  overflow-y: hidden;
  font-family: inherit;
  font-size: 16px;
  line-height: 1.4;
  height: 40px;
  margin-bottom: 0;
  position: relative;
  bottom: 0;
  outline: none;
  box-shadow: none;
  max-width: none;
}
.send-icon {
  width: 40px;
  height: 40px;
  cursor: pointer;
  fill: var(--action);
  flex-shrink: 0;
  user-select: none;
  transition: filter 0.2s ease;
  margin-right: 0;
  vertical-align: bottom;
  outline: none;
}
.send-icon:hover,
.send-icon:active,
.send-icon:focus {
  filter: none;
  outline: none;
  box-shadow: none;
}

@keyframes bounce {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-6px); }
}
.pop-bubble {
  display: inline-flex;
  max-width: 70%;
  gap: 6px;
  margin-bottom: 10px;
  align-items: center;
  white-space: nowrap;
}
.pop-dot {
  width: 10px;
  height: 10px;
  background-color: var(--teams-blue);
  border-radius: 50%;
  animation-name: bounce;
  animation-duration: 1.2s;
  animation-iteration-count: infinite;
  animation-timing-function: ease-in-out;
}
.pop-dot:nth-child(1) {
  animation-delay: 0s;
}
.pop-dot:nth-child(2) {
  animation-delay: 0.2s;
}
.pop-dot:nth-child(3) {
  animation-delay: 0.4s;
}

/* Utilities */
.hidden-element { display: none !important; }
</style>
</head>
<body>
<div class="phone" id="phone">
  <!-- Statischer Header: bleibt beim Übergang unverändert -->
  <div class="app-header">
    <div class="ms-logo"><img src="Teams.png" alt="Microsoft Teams Logo"></div>
    <div class="logo"><img src="00_Logo_CWE.png" alt="CWE Logo"></div>
  </div>

  <!-- Chatliste -->
  <div id="chatList" class="visible">
    <div class="chat-item" data-person="tina">
      <img src="Tina.png" alt="Tina Müller" />
      <div class="info"><div class="name">Tina Müller</div><div class="role">Finanzabteilung</div></div>
    </div>
    <div class="chat-item" data-person="christian">
      <img src="Christian.png" alt="Christian Weber" />
      <div class="info"><div class="name">Christian Weber</div><div class="role">Marketing</div></div>
    </div>
    <div class="chat-item" data-person="hakan">
      <img src="Hakan.png" alt="Hakan Serdar" />
      <div class="info"><div class="name">Hakan Serdar</div><div class="role">Rechtsabteilung</div></div>
    </div>
    <div class="chat-item" data-person="sophie">
      <img src="Sophie.png" alt="Sophie Fischer" />
      <div class="info"><div class="name">Sophie Fischer</div><div class="role">Personalabteilung</div></div>
    </div>
    <div class="chat-item" data-person="sarah">
      <img src="Sarah.png" alt="Sarah Hosse" />
      <div class="info"><div class="name">Sarah Hosse</div><div class="role">Verkauf</div></div>
    </div>
    <div class="chat-item" data-person="timo">
      <img src="Timo.png" alt="Timo Jung" />
      <div class="info"><div class="name">Timo Jung</div><div class="role">Wirtschaftsanalyse</div></div>
    </div>
    <div class="chat-item" data-person="elke">
      <img src="Elke.png" alt="Elke Wagner" />
      <div class="info"><div class="name">Elke Wagner</div><div class="role">Empfang, Ausbildung & Schule</div></div>
    </div>
  </div>

  <!-- Chatfenster -->
  <div id="chatWindow" class="hidden content-building" aria-hidden="true">
    <div class="chat-header">
      <span class="back-btn" id="backBtn" role="button" tabindex="0">←</span>
      <img id="chatAvatar" src="" alt="Avatar" />
      <div><div class="name" id="chatName"></div></div>
    </div>
    <div class="desc" id="chatDescription"></div>
    <div class="messages" id="messages" aria-live="polite"></div>

    <!-- Composer: fixed, id used by JS -->
    <div class="composer" id="composer-container" aria-label="Nachrichtenbereich">
      <div class="composer-inner">
        <textarea id="input" placeholder="Nachricht eingeben..." rows="1" aria-label="Nachricht eingeben"></textarea>
        <svg id="send" class="send-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" aria-label="Senden" role="button" tabindex="0" >
          <path d="M2.01 21L23 12 2.01 3v7l15 2-15 2z"/>
        </svg>
      </div>
    </div>
  </div>
</div>

<script>
/* -------------------------
   App core (kept behavior)
   ------------------------- */

const profiles = {
  tina: { name: "Tina Müller", avatar: "Tina.png", desc: "Tina arbeitet in der Finanzabteilung und ist dir bei allen Fragestellungen rund um Finanzen behilflich." },
  christian: { name: "Christian Weber", avatar: "Christian.png", desc: "Christian arbeitet in der Marketingabteilung und ist dir bei allen Fragestellungen rund um Marketing behilflich." },
  hakan: { name: "Hakan Serdar", avatar: "Hakan.png", desc: "Hakan arbeitet in der Rechtsabteilung und ist dir bei allen rechtlichen Fragestellungen behilflich." },
  sophie: { name: "Sophie Fischer", avatar: "Sophie.png", desc: "Sophie arbeitet in der Personalabteilung und ist dir bei allen Fragestellungen rund um Personal behilflich." },
  sarah: { name: "Sarah Hosse", avatar: "Sarah.png", desc: "Sarah arbeitet im Verkauf und ist dir bei allen Fragestellungen rund um den Verkauf behilflich." },
  timo: { name: "Timo Jung", avatar: "Timo.png", desc: "Timo arbeitet als Analyst bei der CWE und ist dir bei allen volkswirtschaftlichen Fragestellungen behilflich." },
  elke: { name: "Elke Wagner", avatar: "Elke.png", desc: "Elke arbeitet am Empfang und ist dir bei allen Fragestellungen behilflich, bei denen dir sonst niemand helfen kann. Außerdem ist sie deine Ausbildungskoordinatorin und hilft dir auch bei Fragen rund um die Berufsschule weiter." }
};

const phone = document.getElementById('phone');
const chatList = document.getElementById("chatList");
const chatWindow = document.getElementById("chatWindow");
const messagesDiv = document.getElementById("messages");
const chatDescription = document.getElementById("chatDescription");
const chatName = document.getElementById("chatName");
const chatAvatar = document.getElementById("chatAvatar");
const backBtn = document.getElementById("backBtn");
const input = document.getElementById("input");
const send = document.getElementById("send");
const composer = document.getElementById("composer-container");

let currentPerson = null;
const history = { tina:[], christian:[], hakan:[], sophie:[], sarah:[], timo:[], elke:[] };
let popBubbleElement = null;

function hideChatContent() { chatWindow.classList.add('content-building'); }
function showChatContent() { chatWindow.classList.remove('content-building'); }

function scrollToBottom({ smooth = true } = {}) {
  requestAnimationFrame(() => {
    try { messagesDiv.scrollTo({ top: messagesDiv.scrollHeight, behavior: smooth ? 'smooth' : 'auto' }); }
    catch { messagesDiv.scrollTop = messagesDiv.scrollHeight; }
  });
}

function addMessage(text, who, { scroll = true } = {}) {
  const div = document.createElement("div");
  div.className = "msg " + who;
  div.textContent = text;
  messagesDiv.appendChild(div);
  if (scroll) scrollToBottom();
  return div;
}

function moveChatItemToTop(person) {
  const item = document.querySelector(`.chat-item[data-person="${person}"]`);
  if (item) { chatList.removeChild(item); chatList.insertBefore(item, chatList.firstChild); }
}

function openChat(person) {
  currentPerson = person;
  hideChatContent();

  chatWindow.classList.add('hidden');
  chatWindow.classList.remove('visible');
  chatList.classList.remove('hidden');
  chatList.classList.add('visible');

  chatName.textContent = profiles[person].name;
  chatAvatar.src = profiles[person].avatar;

  if (history[person].length === 0) {
    chatDescription.textContent = profiles[person].desc;
    chatDescription.style.display = "block";
  } else chatDescription.style.display = "none";

  messagesDiv.innerHTML = "";
  const prevScrollBehavior = messagesDiv.style.scrollBehavior;
  messagesDiv.style.scrollBehavior = 'auto';
  history[person].forEach(msg => {
    const div = document.createElement("div");
    div.className = "msg " + msg.who;
    div.textContent = msg.text;
    messagesDiv.appendChild(div);
  });
  scrollToBottom({ smooth: false });
  messagesDiv.style.scrollBehavior = prevScrollBehavior || '';

  input.value = "";
  adjustTextareaHeight();

  requestAnimationFrame(() => {
    void chatWindow.offsetHeight;
    chatWindow.classList.remove('hidden');
    chatWindow.classList.add('visible');
    chatWindow.setAttribute('aria-hidden', 'false');
    chatList.classList.remove('visible');
    chatList.classList.add('hidden');
    chatWindow.addEventListener('transitionend', () => showChatContent(), { once: true });
  });
}

function backToChatList() {
  try { if (document.activeElement?.blur) document.activeElement.blur(); if (input?.blur) input.blur(); } catch {}
  hideChatContent();
  chatList.classList.remove('hidden'); chatList.classList.add('visible');
  chatWindow.classList.remove('visible'); chatWindow.classList.add('hidden'); chatWindow.setAttribute('aria-hidden', 'true');
  currentPerson = null;
}

function adjustTextareaHeight() {
  input.style.height = "auto";
  const minHeight = 40, maxHeight = 140;
  const scrollHeight = input.scrollHeight;
  if (scrollHeight < minHeight) { input.style.height = minHeight + "px"; input.style.overflowY = "hidden"; }
  else if (scrollHeight > maxHeight) { input.style.height = maxHeight + "px"; input.style.overflowY = "scroll"; }
  else { input.style.height = scrollHeight + "px"; input.style.overflowY = "hidden"; }
  let growAmount = scrollHeight - 40; if (growAmount < 0) growAmount = 0;
  input.style.marginTop = `-${growAmount}px`;
}

function isTouchDevice() { return (('ontouchstart' in window) || (navigator.maxTouchPoints > 0)); }

document.querySelectorAll(".chat-item").forEach(item => item.addEventListener("click", () => openChat(item.dataset.person)));

function showPopBubble() {
  if (popBubbleElement) return;
  popBubbleElement = document.createElement("div");
  popBubbleElement.className = "pop-bubble";
  for (let i = 0; i < 3; i++) {
    const dot = document.createElement("div");
    dot.className = "pop-dot";
    dot.style.animationDelay = (i * 0.2) + "s";
    popBubbleElement.appendChild(dot);
  }
  messagesDiv.appendChild(popBubbleElement);
  scrollToBottom();
}
function removePopBubble() { if (popBubbleElement) { popBubbleElement.remove(); popBubbleElement = null; } }

function buildMessages() { return history[currentPerson].map(m => ({ role: m.who === "user" ? "user" : "assistant", content: m.text })); }

async function sendMessage() {
  const text = input.value.trim();
  if (!text || !currentPerson) return;
  addMessage(text, "user");
  history[currentPerson].push({ text, who: "user" });
  showPopBubble();
  input.value = "";
  adjustTextareaHeight();
  if (chatDescription.style.display !== "none") chatDescription.style.display = "none";
  try {
    const resp = await fetch("/api/chat", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ person: currentPerson, messages: buildMessages() })
    });
    const data = await resp.json();
    const answer = data.message?.content ?? "Fehler.";
    removePopBubble();
    addMessage(answer, "bot");
    history[currentPerson].push({ text: answer, who: "bot" });
    moveChatItemToTop(currentPerson);
  } catch (e) {
    removePopBubble();
    addMessage("Beim Senden der Nachricht ist ein Fehler aufgetreten.", "bot");
  }
}

input.addEventListener("keydown", e => {
  if (isTouchDevice()) return;
  if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); sendMessage(); }
});
input.addEventListener("input", adjustTextareaHeight);
send.addEventListener("click", sendMessage);
backBtn.addEventListener("click", backToChatList);
backBtn.addEventListener("keydown", e => { if (e.key === "Enter" || e.key === " ") { e.preventDefault(); backToChatList(); } });
send.addEventListener("keydown", e => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); sendMessage(); } });

/* Swipe gestures (kept as before) */
let touchStartX = null, touchStartY = null, touchMoveX = null, touchMoveY = null, dragging = false;
chatWindow.addEventListener('touchstart', function(e) {
  if (e.touches.length === 1) {
    touchStartX = e.touches[0].clientX; touchStartY = e.touches[0].clientY;
    touchMoveX = null; touchMoveY = null; dragging = false;
  }
}, {passive: true});
chatWindow.addEventListener('touchmove', function(e) {
  if (e.touches.length === 1 && touchStartX !== null && touchStartY !== null) {
    touchMoveX = e.touches[0].clientX; touchMoveY = e.touches[0].clientY;
    const deltaX = touchMoveX - touchStartX; const deltaY = touchMoveY - touchStartY;
    const absDeltaX = Math.abs(deltaX); const absDeltaY = Math.abs(deltaY);
    const swipeStartedLeftArea = touchStartX < 100;
    if (swipeStartedLeftArea && deltaX > 0 && absDeltaX > absDeltaY) {
      dragging = true;
      hideChatContent();
      e.preventDefault && e.preventDefault();
      chatWindow.style.transition = 'none';
      chatList.style.transition = 'none';
      chatList.classList.remove('hidden'); chatList.classList.add('visible'); chatList.style.pointerEvents = 'auto';
      const translateX = Math.min(window.innerWidth, deltaX);
      chatWindow.style.transform = `translateX(${translateX}px)`;
      const pct = Math.min(1, deltaX / window.innerWidth);
      const listTranslate = -100 + (pct * 100);
      chatList.style.transform = `translateX(${listTranslate}%)`;
    }
  }
}, {passive: false});
chatWindow.addEventListener('touchend', function(e) {
  if (touchStartX !== null && touchMoveX !== null && touchStartY !== null && touchMoveY !== null) {
    const deltaX = touchMoveX - touchStartX; const deltaY = touchMoveY - touchStartY;
    const absDeltaX = Math.abs(deltaX); const absDeltaY = Math.abs(deltaY);
    const swipeStartedLeftArea = touchStartX < 100;
    if (dragging && swipeStartedLeftArea && deltaX > 50 && absDeltaX > absDeltaY) {
      try { if (document.activeElement?.blur) document.activeElement.blur(); if (input?.blur) input.blur(); } catch {}
      hideChatContent();
      chatWindow.style.transition = ''; chatList.style.transition = '';
      chatWindow.style.transform = `translateX(${window.innerWidth}px)`; chatList.style.transform = `translateX(0%)`;
      const cleanup = () => {
        chatWindow.style.transition = '';
        chatWindow.style.transform = '';
        chatList.style.transform = '';
        chatList.style.pointerEvents = '';
        chatWindow.classList.remove('visible'); chatWindow.classList.add('hidden');
        chatWindow.setAttribute('aria-hidden', 'true');
        chatWindow.removeEventListener('transitionend', cleanup);
      };
      chatWindow.addEventListener('transitionend', cleanup);
      chatList.classList.remove('hidden'); chatList.classList.add('visible');
      currentPerson = null;
    } else {
      chatWindow.style.transition = ''; chatList.style.transition = '';
      chatWindow.style.transform = ''; chatList.style.transform = '';
      if (!chatWindow.classList.contains('hidden')) { chatWindow.classList.add('visible'); chatWindow.classList.remove('hidden'); }
      chatList.classList.remove('visible'); chatList.classList.add('hidden'); chatList.style.pointerEvents = '';
      showChatContent();
    }
  }
  touchStartX = null; touchStartY = null; touchMoveX = null; touchMoveY = null; dragging = false;
}, {passive: true});

/* click to blur */
messagesDiv.addEventListener('click', () => { if (document.activeElement === input) input.blur(); });

/* -------------------------
   A2 Keyboard + Composer controller
   - Composer moves only
   - UI (phone) remains visually in place
   - Messages get extra padding while keyboard open so last messages remain visible
   - Works with visualViewport (iOS Safari) + fallback resize
   ------------------------- */

(function keyboardController() {
  if (!composer || !messagesDiv || !phone) return;

  const root = document.documentElement;
  const composerEl = composer;
  const messagesEl = messagesDiv;
  const phoneEl = phone;

  const composerHeight = () => {
    const h = composerEl.getBoundingClientRect().height;
    return Math.round(h || parseInt(getComputedStyle(root).getPropertyValue('--composer-height')) || 65);
  };

  // Save & restore phone inline styles if we need to fix it in viewport to avoid browser pan
  let savedPhoneStyles = null;
  let phoneFixed = false;

  function savePhoneStyles() {
    savedPhoneStyles = {
      position: phoneEl.style.position || '',
      top: phoneEl.style.top || '',
      left: phoneEl.style.left || '',
      width: phoneEl.style.width || '',
      marginLeft: phoneEl.style.marginLeft || '',
      marginRight: phoneEl.style.marginRight || '',
      transform: phoneEl.style.transform || '',
      transition: phoneEl.style.transition || '',
    };
  }
  function restorePhoneStyles() {
    if (!savedPhoneStyles) return;
    phoneEl.style.position = savedPhoneStyles.position;
    phoneEl.style.top = savedPhoneStyles.top;
    phoneEl.style.left = savedPhoneStyles.left;
    phoneEl.style.width = savedPhoneStyles.width;
    phoneEl.style.marginLeft = savedPhoneStyles.marginLeft;
    phoneEl.style.marginRight = savedPhoneStyles.marginRight;
    phoneEl.style.transform = savedPhoneStyles.transform;
    phoneEl.style.transition = savedPhoneStyles.transition;
    phoneEl.classList.remove('phone--fixed');
    phoneFixed = false;
  }
  function fixPhoneToViewport() {
    if (phoneFixed) return;
    const rect = phoneEl.getBoundingClientRect();
    savePhoneStyles();
    phoneEl.style.position = 'fixed';
    phoneEl.style.top = `${rect.top}px`;
    phoneEl.style.left = `${rect.left}px`;
    phoneEl.style.width = `${rect.width}px`;
    phoneEl.style.marginLeft = '0';
    phoneEl.style.marginRight = '0';
    phoneEl.style.transform = 'none';
    phoneEl.style.transition = 'none';
    phoneEl.classList.add('phone--fixed');
    phoneFixed = true;
  }

  function unfixPhoneFromViewport() {
    if (!phoneFixed) return;
    restorePhoneStyles();
  }

  function applyComposerOffset(offsetPx) {
    // Move composer up by offsetPx (keyboard height)
    composerEl.style.transform = `translateY(-${Math.round(offsetPx)}px)`;
    // increase messages padding so last messages are above composer+keyboard
    const pb = composerHeight() + 12 + Math.round(offsetPx);
    messagesEl.style.paddingBottom = pb + 'px';
    // scroll to bottom so last messages remain visible above composer
    scrollToBottom({ smooth: true });
  }

  function clearComposerOffset() {
    composerEl.style.transform = '';
    messagesEl.style.paddingBottom = (composerHeight() + 12) + 'px';
    // small scroll to ensure layout stable
    scrollToBottom({ smooth: false });
  }

  // Heuristic to detect iOS
  const ua = navigator.userAgent || navigator.vendor || window.opera;
  const isIOS = /iP(ad|hone|od)/i.test(ua);

  // Handler using visualViewport when available (best for iOS Safari)
  function handleVisualViewport(vv) {
    if (!vv) return;
    const layoutH = window.innerHeight;
    const vvHeight = vv.height || layoutH;
    // keyboard height = layoutHeight - visualViewport.height (or offsetTop)
    let keyboardHeight = Math.max(0, Math.round(layoutH - vvHeight));
    if (vv.offsetTop && vv.offsetTop > 0) {
      // prefer offsetTop when available (accurate on iOS)
      keyboardHeight = Math.max(keyboardHeight, Math.round(vv.offsetTop));
    }

    if (keyboardHeight > 80) {
      // keyboard open
      // Fix phone to viewport on iOS to avoid Safari panning the whole page
      if (isIOS) fixPhoneToViewport();
      applyComposerOffset(keyboardHeight);
    } else {
      // keyboard closed
      clearComposerOffset();
      // restore phone fixed after a tiny delay to let viewport settle
      setTimeout(() => { unfixPhoneFromViewport(); }, 60);
    }
  }

  // Fallback for browsers without visualViewport (Android / older)
  let baselineInner = window.innerHeight;
  function handleResizeFallback() {
    const newInner = window.innerHeight;
    const diff = Math.max(0, baselineInner - newInner);
    if (diff > 120) {
      if (isIOS) fixPhoneToViewport();
      applyComposerOffset(diff);
    } else {
      clearComposerOffset();
      setTimeout(() => { unfixPhoneFromViewport(); }, 60);
      baselineInner = newInner;
    }
  }

  // Attach listeners
  if (window.visualViewport) {
    const vv = window.visualViewport;
    const vvHandler = () => handleVisualViewport(vv);
    vv.addEventListener('resize', vvHandler, { passive: true });
    vv.addEventListener('scroll', vvHandler, { passive: true });
    // call once to sync initial state
    handleVisualViewport(vv);
    // Ensure focus events also trigger a check (some Safari builds delay visualViewport)
    input.addEventListener('focus', () => setTimeout(() => handleVisualViewport(vv), 60), { passive: true });
    input.addEventListener('blur', () => setTimeout(() => handleVisualViewport(vv), 120), { passive: true });
  } else {
    // fallback
    window.addEventListener('resize', handleResizeFallback, { passive: true });
    input.addEventListener('focus', () => setTimeout(handleResizeFallback, 60), { passive: true });
    input.addEventListener('blur', () => setTimeout(handleResizeFallback, 120), { passive: true });
  }

  // Keep default padding in sync if composer height changes
  new ResizeObserver(() => {
    // only adjust padding bottom (keep keyboard offset logic unchanged)
    messagesEl.style.paddingBottom = (composerHeight() + 12) + 'px';
  }).observe(composerEl);

  // Initialize messages padding to composer height
  messagesEl.style.paddingBottom = (composerHeight() + 12) + 'px';
})();

/* End keyboardController */

</script>
</body>
</html>
