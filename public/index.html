<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>CWE – Mitarbeiterchat</title>
<style>
:root {
  --bg: #121212;
  --surface: #1E1E1E;
  --surface-light: #2A2A2A;
  --text: #EAEAEA;
  --text-dim: #A8A8A8;
  --accent: #6264A7;
  --action: #6264A7;
  --bubble-user: var(--action);
  --bubble-bot: #2A2A2A;
  --border: #333;
  --desc-gray: #888;
  --teams-blue: #6264A7;
  --app-header-height: 70px;
  --composer-height: 90px; /* zentrale Composer-Höhe (wird als Referenz genutzt) */
}
* { box-sizing: border-box; }
html, body {
  width: 100%;
  height: 100%;
  overflow: hidden;
  touch-action: manipulation;
}
body {
  margin: 0;
  background: var(--bg);
  color: var(--text);
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  display: flex;
  justify-content: center;
  align-items: stretch;
  font-size: 17px;
  overscroll-behavior: none;
}

/* Geräteraum */
.phone {
  width: 100%;
  max-width: 600px;
  height: 100dvh;
  min-height: 100%;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  position: relative;
}

/* Header */
.app-header {
  background: white;
  height: var(--app-header-height);
  padding: 0 18px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;
  font-weight: 600;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  z-index: 100;
  color: #000000;
  user-select: none;
  flex-shrink: 0;
}
.app-header .ms-logo { position: absolute; left: 18px; width: 32px; height: 32px; display:flex; align-items:center; justify-content:center; }
.app-header .ms-logo img { max-width:100%; max-height:100%; }
.app-header .logo { position: absolute; right: 18px; height: 40px; }
.app-header .logo img { height: 40px; width: auto; }

/* Animierte Bereiche unter Header */
#chatList, #chatWindow {
  position: absolute;
  left: 0; right: 0;
  top: var(--app-header-height);
  bottom: 0;
  transition: transform 0.35s ease, opacity 0.35s ease;
  will-change: transform, opacity;
  background: var(--surface);
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  -webkit-overflow-scrolling: touch;
}

/* Sichtbarkeit */
#chatList.visible { opacity: 1; pointer-events: auto; transform: translateX(0); z-index: 40; }
#chatList.hidden { opacity: 0; pointer-events: none; transform: translateX(-100%); z-index: 0; }
#chatWindow.visible { opacity: 1; pointer-events: auto; transform: translateX(0); z-index: 50; display: flex; }
#chatWindow.hidden { opacity: 0; pointer-events: none; transform: translateX(100%); z-index: 0; display: flex; }

/* Chatliste Items */
#chatList { background: var(--surface); }
.chat-item { display:flex; align-items:center; padding:12px; gap:12px; border-bottom:1px solid var(--border); cursor:pointer; }
.chat-item:hover { background:#2b2b2b; }
.chat-item img { width:52px; height:52px; border-radius:50%; object-fit:cover; background:var(--surface-light); }
.chat-item .info .name { font-size:16px; font-weight:600; }
.chat-item .info .role { font-size:14px; color:var(--text-dim); }

/* Beschreibung */
.desc { background:var(--surface); color:var(--desc-gray); font-size:14px; line-height:1.4; margin:10px 14px; padding:8px; border-radius:8px; white-space:pre-wrap; word-break:break-word; }

/* Chatfenster */
#chatWindow { flex-direction: column; overflow: hidden; }

/* Chat-Header */
.chat-header { background:var(--surface-light); display:flex; align-items:center; padding:10px 14px; border-bottom:1px solid var(--border); z-index:1; flex-shrink:0; }
.back-btn { font-size:23px; cursor:pointer; color:var(--action); margin-right:15px; user-select:none; }
.chat-header img { width:42px; height:42px; border-radius:50%; object-fit:cover; background:var(--surface-light); margin-right:15px; }
.chat-header .name { font-size:16px; font-weight:600; }

/* Nachrichtenbereich */
.messages {
  flex: 1 1 auto;
  overflow-y: auto;
  padding: 10px 14px;
  display:flex;
  flex-direction:column;
  gap:10px;
  scrollbar-width: thin;
  scrollbar-color: var(--accent) transparent;
  scroll-behavior: smooth;
  -webkit-overflow-scrolling: touch;
  overscroll-behavior: contain;
  /* Wichtig: genug Platz unten reservieren, damit Inhalte nicht dauerhaft hinter Composer verschwinden.
     Diese Padding-Bottom wird per JS dynamisch gesetzt, damit beim Composer-overlay die letzten Nachrichten sichtbar bleiben */
  padding-bottom: calc(var(--composer-height) + 12px);
}
.msg { max-width:75%; padding:10px 14px; border-radius:14px; font-size:15px; line-height:1.4; white-space:pre-wrap; word-break:break-word; color:var(--text); }
.msg.user { background:var(--bubble-user); align-self:flex-end; }
.msg.bot { background:var(--bubble-bot); border:1px solid var(--border); align-self:flex-start; }

/* Inhalte während Übergang unsichtbar halten */
#chatWindow.content-building .desc,
#chatWindow.content-building .messages { opacity:0; pointer-events:none; transition: opacity 0.15s ease; }

/* Composer: standardmäßig sticky bottom:0 */
.composer {
  background: var(--surface);
  border: none;
  padding: 8px 0;
  display: flex;
  gap: 8px;
  align-items: flex-end;
  flex-shrink: 0;
  position: sticky;
  bottom: 0;
  height: var(--composer-height);
  transform: translateY(-7.5px);
  transition: bottom 0.18s ease, transform 0.18s ease;
  z-index: 60; /* über Nachrichten */
}
.composer-inner { display:flex; align-items:flex-end; gap:8px; width:100%; padding-left:14px; padding-right:14px; }
.composer textarea {
  flex:1; min-height:40px; max-height:140px; background:var(--surface); color:var(--text);
  border:1px solid white; border-radius:10px; padding:8px 20px; resize:none; overflow-y:hidden; font-family:inherit;
  font-size:16px; line-height:1.4; height:40px; outline:none;
}
.send-icon { width:40px; height:40px; cursor:pointer; fill:var(--action); flex-shrink:0; user-select:none; transition:filter 0.2s ease; }

/* Composer wenn overlay aktiv: wir ändern per JS auf 'position: fixed' + bottom set */
.composer--overlay {
  position: fixed !important;
  left: 0;
  right: 0;
  margin: 0 auto;
  /* bottom wird per JS gesetzt */
  width: 100%;
  max-width: 600px; /* entspricht .phone max-width */
  z-index: 120;
  /* leicht erhöhte shadow, damit es sichtbar über dem Chat liegt */
  box-shadow: 0 -6px 18px rgba(0,0,0,0.45);
}

/* Pop bubble */
@keyframes bounce { 0%,100%{transform:translateY(0);} 50%{transform:translateY(-6px);} }
.pop-bubble { display:inline-flex; max-width:70%; gap:6px; margin-bottom:10px; align-items:center; white-space:nowrap; }
.pop-dot { width:10px; height:10px; background-color:var(--teams-blue); border-radius:50%; animation:bounce 1.2s infinite ease-in-out; }
.hidden-element { display: none !important; }

@media (max-width:420px) {
  :root { --app-header-height:64px; --composer-height:82px; }
  .chat-item img { width:48px; height:48px; }
}
</style>
</head>
<body>
<div class="phone">
  <div class="app-header">
    <div class="ms-logo"><img src="Teams.png" alt="Microsoft Teams Logo"></div>
    <div class="logo"><img src="00_Logo_CWE.png" alt="CWE Logo"></div>
  </div>

  <div id="chatList" class="visible">
    <div class="chat-item" data-person="tina">
      <img src="Tina.png" alt="Tina Müller" />
      <div class="info"><div class="name">Tina Müller</div><div class="role">Finanzabteilung</div></div>
    </div>
    <div class="chat-item" data-person="christian">
      <img src="Christian.png" alt="Christian Weber" />
      <div class="info"><div class="name">Christian Weber</div><div class="role">Marketing</div></div>
    </div>
    <div class="chat-item" data-person="hakan">
      <img src="Hakan.png" alt="Hakan Serdar" />
      <div class="info"><div class="name">Hakan Serdar</div><div class="role">Rechtsabteilung</div></div>
    </div>
    <div class="chat-item" data-person="sophie">
      <img src="Sophie.png" alt="Sophie Fischer" />
      <div class="info"><div class="name">Sophie Fischer</div><div class="role">Personalabteilung</div></div>
    </div>
    <div class="chat-item" data-person="sarah">
      <img src="Sarah.png" alt="Sarah Hosse" />
      <div class="info"><div class="name">Sarah Hosse</div><div class="role">Verkauf</div></div>
    </div>
    <div class="chat-item" data-person="timo">
      <img src="Timo.png" alt="Timo Jung" />
      <div class="info"><div class="name">Timo Jung</div><div class="role">Wirtschaftsanalyse</div></div>
    </div>
    <div class="chat-item" data-person="elke">
      <img src="Elke.png" alt="Elke Wagner" />
      <div class="info"><div class="name">Elke Wagner</div><div class="role">Empfang, Ausbildung & Schule</div></div>
    </div>
  </div>

  <div id="chatWindow" class="hidden content-building" aria-hidden="true">
    <div class="chat-header">
      <span class="back-btn" id="backBtn" role="button" tabindex="0">←</span>
      <img id="chatAvatar" src="" alt="Avatar" />
      <div><div class="name" id="chatName"></div></div>
    </div>

    <div class="desc" id="chatDescription"></div>
    <div class="messages" id="messages" aria-live="polite"></div>

    <div class="composer" id="composer" aria-label="Nachrichtenbereich">
      <div class="composer-inner">
        <textarea id="input" placeholder="Nachricht eingeben..." rows="1" aria-label="Nachricht eingeben"></textarea>
        <svg id="send" class="send-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" aria-label="Senden" role="button" tabindex="0">
          <path d="M2.01 21L23 12 2.01 3v7l15 2-15 2z"/>
        </svg>
      </div>
    </div>
  </div>
</div>

<script>
/* ===========================================================
   Ziel: Variante A2 - Chat bleibt an Ort und Stelle, nur der
   Composer "overlayt" und sitzt direkt oberhalb der On-Screen
   Keyboard-Fläche. Beim Schließen der Tastatur kehrt alles zurück.
   =========================================================== */

const profiles = {
  tina: { name: "Tina Müller", avatar: "Tina.png", desc: "Tina arbeitet in der Finanzabteilung und ist dir bei allen Fragestellungen rund um Finanzen behilflich." },
  christian: { name: "Christian Weber", avatar: "Christian.png", desc: "Christian arbeitet in der Marketingabteilung und ist dir bei allen Fragestellungen rund um Marketing behilflich." },
  hakan: { name: "Hakan Serdar", avatar: "Hakan.png", desc: "Hakan arbeitet in der Rechtsabteilung und ist dir bei allen rechtlichen Fragestellungen behilflich." },
  sophie: { name: "Sophie Fischer", avatar: "Sophie.png", desc: "Sophie arbeitet in der Personalabteilung und ist dir bei allen Fragestellungen rund um Personal behilflich." },
  sarah: { name: "Sarah Hosse", avatar: "Sarah.png", desc: "Sarah arbeitet im Verkauf und ist dir bei allen Fragestellungen rund um den Verkauf behilflich." },
  timo: { name: "Timo Jung", avatar: "Timo.png", desc: "Timo arbeitet als Analyst bei der CWE und ist dir bei allen volkswirtschaftlichen Fragestellungen behilflich." },
  elke: { name: "Elke Wagner", avatar: "Elke.png", desc: "Elke arbeitet am Empfang und ist dir bei allen Fragestellungen behilflich, bei denen dir sonst niemand helfen kann. Außerdem ist sie deine Ausbildungskoordinatorin und hilft dir auch bei Fragen rund um die Berufsschule weiter." }
};

const chatList = document.getElementById("chatList");
const chatWindow = document.getElementById("chatWindow");
const messagesDiv = document.getElementById("messages");
const chatDescription = document.getElementById("chatDescription");
const chatName = document.getElementById("chatName");
const chatAvatar = document.getElementById("chatAvatar");
const backBtn = document.getElementById("backBtn");
const input = document.getElementById("input");
const send = document.getElementById("send");
const composer = document.getElementById("composer");

let currentPerson = null;
const history = { tina:[], christian:[], hakan:[], sophie:[], sarah:[], timo:[], elke:[] };
let popBubbleElement = null;

/* ---------- Scroll / Message helpers ---------- */
function scrollToBottom({ smooth = true } = {}) {
  requestAnimationFrame(() => {
    try {
      messagesDiv.scrollTo({ top: messagesDiv.scrollHeight, behavior: smooth ? "smooth" : "auto" });
    } catch (e) {
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }
  });
}

function addMessage(text, who, { scroll = true } = {}) {
  const div = document.createElement("div");
  div.className = "msg " + who;
  div.textContent = text;
  messagesDiv.appendChild(div);
  if (scroll) scrollToBottom();
  return div;
}

function moveChatItemToTop(person) {
  const item = document.querySelector(`.chat-item[data-person="${person}"]`);
  if (item) {
    chatList.removeChild(item);
    chatList.insertBefore(item, chatList.firstChild);
  }
}

/* ---------- Chat open/close ---------- */
function hideChatContent() { chatWindow.classList.add('content-building'); }
function showChatContent() { chatWindow.classList.remove('content-building'); }

function openChat(person) {
  currentPerson = person;
  hideChatContent();

  chatWindow.classList.add('hidden');
  chatWindow.classList.remove('visible');
  chatList.classList.remove('hidden');
  chatList.classList.add('visible');

  chatName.textContent = profiles[person].name;
  chatAvatar.src = profiles[person].avatar;

  if (history[person].length === 0) {
    chatDescription.textContent = profiles[person].desc;
    chatDescription.style.display = "block";
  } else {
    chatDescription.style.display = "none";
  }

  messagesDiv.innerHTML = "";
  const prevScrollBehavior = messagesDiv.style.scrollBehavior;
  messagesDiv.style.scrollBehavior = 'auto';
  history[person].forEach(msg => {
    const div = document.createElement("div");
    div.className = "msg " + msg.who;
    div.textContent = msg.text;
    messagesDiv.appendChild(div);
  });
  scrollToBottom({ smooth: false });
  messagesDiv.style.scrollBehavior = prevScrollBehavior || '';

  input.value = "";
  adjustTextareaHeight();

  requestAnimationFrame(() => {
    void chatWindow.offsetHeight;
    chatWindow.classList.remove('hidden');
    chatWindow.classList.add('visible');
    chatWindow.setAttribute('aria-hidden', 'false');

    chatList.classList.remove('visible');
    chatList.classList.add('hidden');

    chatWindow.addEventListener('transitionend', () => showChatContent(), { once: true });
  });
}

function backToChatList() {
  try {
    if (document.activeElement && typeof document.activeElement.blur === 'function') document.activeElement.blur();
    if (input && typeof input.blur === 'function') input.blur();
  } catch (e) {}
  hideChatContent();
  chatList.classList.remove('hidden');
  chatList.classList.add('visible');
  chatWindow.classList.remove('visible');
  chatWindow.classList.add('hidden');
  chatWindow.setAttribute('aria-hidden', 'true');
  currentPerson = null;
}

/* ---------- Textarea resize ---------- */
function adjustTextareaHeight() {
  input.style.height = "auto";
  const minHeight = 40;
  const maxHeight = 140;
  const scrollHeight = input.scrollHeight;
  if (scrollHeight < minHeight) {
    input.style.height = minHeight + "px";
    input.style.overflowY = "hidden";
  } else if (scrollHeight > maxHeight) {
    input.style.height = maxHeight + "px";
    input.style.overflowY = "scroll";
  } else {
    input.style.height = scrollHeight + "px";
    input.style.overflowY = "hidden";
  }
  let growAmount = scrollHeight - 40;
  if (growAmount < 0) growAmount = 0;
  input.style.marginTop = `-${growAmount}px`;
}

/* ---------- Tippen-Indikator ---------- */
function showPopBubble() {
  if (popBubbleElement) return;
  popBubbleElement = document.createElement("div");
  popBubbleElement.className = "pop-bubble";
  for (let i=0;i<3;i++){ const dot = document.createElement("div"); dot.className="pop-dot"; dot.style.animationDelay=(i*0.2)+"s"; popBubbleElement.appendChild(dot); }
  messagesDiv.appendChild(popBubbleElement);
  scrollToBottom();
}
function removePopBubble() { if (popBubbleElement) { popBubbleElement.remove(); popBubbleElement = null; } }

/* ---------- Backend-Payload & send ---------- */
function buildMessages() {
  return history[currentPerson].map(m => ({ role: m.who === "user" ? "user" : "assistant", content: m.text }));
}

async function sendMessage() {
  const text = input.value.trim();
  if (!text || !currentPerson) return;
  addMessage(text, "user");
  history[currentPerson].push({ text, who: "user" });

  showPopBubble();
  input.value = "";
  adjustTextareaHeight();
  if (chatDescription.style.display !== "none") chatDescription.style.display = "none";

  try {
    const resp = await fetch("/api/chat", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ person: currentPerson, messages: buildMessages() })
    });
    const data = await resp.json();
    const answer = data.message?.content ?? "Fehler.";
    removePopBubble();
    addMessage(answer, "bot");
    history[currentPerson].push({ text: answer, who: "bot" });
    moveChatItemToTop(currentPerson);
  } catch (error) {
    removePopBubble();
    addMessage("Beim Senden der Nachricht ist ein Fehler aufgetreten.", "bot");
  }
}

/* ---------- Events ---------- */
document.querySelectorAll(".chat-item").forEach(item => item.addEventListener("click", ()=> openChat(item.dataset.person)));
input.addEventListener("keydown", e => {
  if (('ontouchstart' in window) || (navigator.maxTouchPoints > 0)) return; // mobile: Enter via send-icon
  if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); sendMessage(); }
});
input.addEventListener("input", () => { adjustTextareaHeight(); });
send.addEventListener("click", sendMessage);
backBtn.addEventListener("click", () => backToChatList());
backBtn.addEventListener("keydown", (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); backToChatList(); } });
messagesDiv.addEventListener("click", () => { if (document.activeElement === input) input.blur(); });
send.addEventListener("keydown", (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); sendMessage(); } });

/* ---------- Variant A2: Composer overlay über Tastatur, Chat bleibt an Ort ---------- */
/*
  Konzept:
  - Standard: Composer ist sticky bottom:0 (im DOM).
  - Bei erkannten Keyboard-Open-Events:
      => Composer bekommt Klasse .composer--overlay (position:fixed) und bottom = keyboardHeight px
      => messages.paddingBottom bleibt der Composer-Höhe, damit letzte Messages sichtbar sind
  - Bei Keyboard-Close: Composer zurück auf sticky bottom:0
  - Erkennung erfolgt primär über visualViewport (wenn vorhanden),
    mit Fallback auf window.innerHeight resize-differenz.
*/

(function keyboardOverlayController() {
  const composerEl = composer;
  const messagesEl = messagesDiv;
  const root = document.documentElement;
  const composerHeight = () => composerEl.getBoundingClientRect().height || parseInt(getComputedStyle(root).getPropertyValue('--composer-height')) || 90;
  let lastKeyboard = 0;
  let originalInnerHeight = window.innerHeight;
  let overlayActive = false;
  let vv = window.visualViewport;

  function setComposerOverlay(keyboardHeight) {
    // keyboardHeight in px (>=0)
    if (!overlayActive) {
      composerEl.classList.add('composer--overlay');
      overlayActive = true;
    }
    // bottom must place composer directly above keyboard
    const bottomPx = Math.max(0, keyboardHeight);
    composerEl.style.bottom = bottomPx + 'px';
    // ensure messages padding-bottom equals composerHeight + comfortable margin
    messagesEl.style.paddingBottom = (composerHeight() + 12) + 'px';
  }

  function clearComposerOverlay() {
    if (!overlayActive) return;
    composerEl.classList.remove('composer--overlay');
    composerEl.style.bottom = '';
    // restore sticky behaviour (CSS already sticky)
    overlayActive = false;
    // maintain original messages padding-bottom equal to composer height
    messagesEl.style.paddingBottom = (composerHeight() + 12) + 'px';
  }

  function onVisualViewportChange() {
    try {
      if (!vv) return;
      /*
        visualViewport gives:
          - height: the layout viewport height (excluding on-screen keyboard in many browsers)
          - offsetTop: vertical offset of visual viewport relative to layout viewport
        Compute keyboardHeight as the difference between layout viewport (window.innerHeight)
        and visual viewport bottom (offsetTop + height).
      */
      const layoutH = window.innerHeight;
      const visibleTop = vv.offsetTop || 0;
      const visibleH = vv.height || layoutH;
      const visibleBottom = visibleTop + visibleH;
      const keyboardHeight = Math.max(0, Math.round(layoutH - visibleBottom));

      // Heuristik: consider keyboard open when keyboardHeight > 80px (small differences ignored)
      if (keyboardHeight > 80) {
        lastKeyboard = keyboardHeight;
        setComposerOverlay(keyboardHeight);
      } else {
        clearComposerOverlay();
      }
    } catch (err) {
      // fallback handled elsewhere
      console.error(err);
    }
  }

  // Fallback using resize: works in many Android browsers
  function onResizeFallback() {
    const newInner = window.innerHeight;
    // if shrink > 150px -> keyboard likely opened (threshold conservative)
    const diff = Math.max(0, originalInnerHeight - newInner);
    if (diff > 120) {
      // keyboard open estimated
      lastKeyboard = diff;
      setComposerOverlay(diff);
    } else {
      // if resized but not keyboard, reset
      // small resizes (orientation) shouldn't trigger overlay removal if overlayActive true and diff small
      if (overlayActive && diff < 60) {
        // likely closed
        clearComposerOverlay();
      } else if (!overlayActive) {
        // update original height after orientation change or initial measurement
        originalInnerHeight = newInner;
      }
    }
  }

  // Initialization: set messages padding-bottom to composer height (so messages never sit exactly under composer)
  messagesEl.style.paddingBottom = (composerHeight() + 12) + 'px';

  // Attach listeners
  if (vv) {
    vv.addEventListener('resize', onVisualViewportChange, { passive: true });
    vv.addEventListener('scroll', onVisualViewportChange, { passive: true });
    // also call once to sync initial state
    onVisualViewportChange();
  }

  // fallback and additional resize handling
  window.addEventListener('resize', () => {
    // give visualViewport a chance to handle it first (if present)
    if (window.visualViewport) {
      // sometimes visualViewport handlers still not accurate; ensure fallback runs after small delay
      setTimeout(onVisualViewportChange, 50);
      return;
    }
    onResizeFallback();
  }, { passive: true });

  // when input focus changes, it's likely keyboard opens; try to proactively compute overlay
  [input].forEach(el => {
    el.addEventListener('focus', () => {
      // If visualViewport available, handler will run; fallback: compute from current window.innerHeight
      setTimeout(() => {
        if (window.visualViewport) {
          onVisualViewportChange();
        } else {
          // approximate: difference from originalInnerHeight
          const diff = Math.max(0, originalInnerHeight - window.innerHeight);
          if (diff > 80) {
            setComposerOverlay(diff);
          } else {
            // Try small overlay offset (safe): 300px typical keyboard height on mobile
            setComposerOverlay(Math.min(400, Math.max(0, diff || 300)));
          }
        }
      }, 50);
    }, { passive: true });

    el.addEventListener('blur', () => {
      // On blur, keyboard usually closes: remove overlay after small delay to allow viewport events to settle
      setTimeout(() => {
        if (window.visualViewport) {
          onVisualViewportChange();
        } else {
          // assume keyboard closed
          clearComposerOverlay();
        }
      }, 120);
    });
  });

  // Also react to orientation change to re-calc baseline
  window.addEventListener('orientationchange', () => {
    // reset baseline after orientation
    setTimeout(() => {
      originalInnerHeight = window.innerHeight;
      // recalc current viewport
      if (window.visualViewport) onVisualViewportChange();
    }, 300);
  });

  // expose debug helpers (optional)
  window.__composerOverlay = {
    setOverlay: (px) => setComposerOverlay(px),
    clear: () => clearComposerOverlay(),
    lastKeyboard: () => lastKeyboard
  };
})();

/* ---------- Swipe gestures, keyboard-close helpers etc. (gleiche Logik wie vorher) ---------- */
/* ... Die vorhandenen Touch-Handler, Swipe-Back, Transition-Handling bleiben unverändert ... */
/* Für Kürze nutze ich die aus deinem Ausgangscode übernommenen Handler weiter (kopiert / leicht angepasst) */

/* Swipe-Geste (Zurück) mit fließender Transition */
let touchStartX = null, touchStartY = null, touchMoveX = null, touchMoveY = null, dragging = false;

chatWindow.addEventListener('touchstart', function(e) {
  if (e.touches.length === 1) {
    touchStartX = e.touches[0].clientX;
    touchStartY = e.touches[0].clientY;
    touchMoveX = null;
    touchMoveY = null;
    dragging = false;
  }
}, {passive: true});

chatWindow.addEventListener('touchmove', function(e) {
  if (e.touches.length === 1 && touchStartX !== null && touchStartY !== null) {
    touchMoveX = e.touches[0].clientX;
    touchMoveY = e.touches[0].clientY;
    const deltaX = touchMoveX - touchStartX;
    const deltaY = touchMoveY - touchStartY;
    const absDeltaX = Math.abs(deltaX);
    const absDeltaY = Math.abs(deltaY);
    const swipeStartedLeftArea = touchStartX < 100;

    if (swipeStartedLeftArea && deltaX > 0 && absDeltaX > absDeltaY) {
      dragging = true;
      hideChatContent();
      e.preventDefault && e.preventDefault();
      chatWindow.style.transition = 'none';
      chatList.style.transition = 'none';
      chatList.classList.remove('hidden');
      chatList.classList.add('visible');
      chatList.style.pointerEvents = 'auto';
      const translateX = Math.min(window.innerWidth, deltaX);
      chatWindow.style.transform = `translateX(${translateX}px)`;
      const pct = Math.min(1, deltaX / window.innerWidth);
      const listTranslate = -100 + (pct * 100);
      chatList.style.transform = `translateX(${listTranslate}%)`;
    }
  }
}, {passive: false});

chatWindow.addEventListener('touchend', function(e) {
  if (touchStartX !== null && touchMoveX !== null && touchStartY !== null && touchMoveY !== null) {
    const deltaX = touchMoveX - touchStartX;
    const deltaY = touchMoveY - touchStartY;
    const absDeltaX = Math.abs(deltaX);
    const absDeltaY = Math.abs(deltaY);
    const swipeStartedLeftArea = touchStartX < 100;

    if (dragging && swipeStartedLeftArea && deltaX > 50 && absDeltaX > absDeltaY) {
      try { if (document.activeElement && typeof document.activeElement.blur === 'function') document.activeElement.blur(); if (input && typeof input.blur === 'function') input.blur(); } catch (e) {}
      hideChatContent();
      chatWindow.style.transition = '';
      chatList.style.transition = '';
      chatWindow.style.transform = `translateX(${window.innerWidth}px)`;
      chatList.style.transform = `translateX(0%)`;
      const cleanup = () => {
        chatWindow.style.transition = '';
        chatWindow.style.transform = '';
        chatList.style.transform = '';
        chatList.style.pointerEvents = '';
        chatWindow.classList.remove('visible');
        chatWindow.classList.add('hidden');
        chatWindow.setAttribute('aria-hidden', 'true');
        chatWindow.removeEventListener('transitionend', cleanup);
      };
      chatWindow.addEventListener('transitionend', cleanup);
      chatList.classList.remove('hidden');
      chatList.classList.add('visible');
      currentPerson = null;
    } else {
      chatWindow.style.transition = '';
      chatList.style.transition = '';
      chatWindow.style.transform = '';
      chatList.style.transform = '';
      if (!chatWindow.classList.contains('hidden')) {
        chatWindow.classList.add('visible');
        chatWindow.classList.remove('hidden');
      }
      chatList.classList.remove('visible');
      chatList.classList.add('hidden');
      chatList.style.pointerEvents = '';
      showChatContent();
    }
  }
  touchStartX = null; touchStartY = null; touchMoveX = null; touchMoveY = null; dragging = false;
}, {passive: true});

/* Accessibility / blur on click / Enter handling */
messagesDiv.addEventListener('click', () => { if (document.activeElement === input) input.blur(); });

/* Enter-Handling (Desktop) */
input.addEventListener("keydown", (e) => {
  if ((('ontouchstart' in window) || (navigator.maxTouchPoints > 0))) return;
  if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); sendMessage(); }
});

/* ensure composer height based padding stays in sync on load and when composer resizes */
function syncComposerPadding() {
  messagesDiv.style.paddingBottom = (composer.getBoundingClientRect().height + 12) + 'px';
}
window.addEventListener('load', syncComposerPadding, { passive: true });
new ResizeObserver(syncComposerPadding).observe(composer);

/* End of script */
</script>
</body>
</html>
