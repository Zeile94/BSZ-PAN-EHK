<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>CWE – Mitarbeiterchat</title>
<style>
:root {
  --bg: #121212;
  --surface: #1E1E1E;
  --surface-light: #2A2A2A;
  --text: #EAEAEA;
  --text-dim: #A8A8A8;
  --accent: #6264A7;
  --action: #6264A7;
  --bubble-user: var(--action);
  --bubble-bot: #2A2A2A;
  --border: #333;
  --desc-gray: #888;
  --teams-blue: #6264A7;
  --app-header-height: 70px;
  --composer-height: 90px; /* zentrale Composer-Höhe */
}
* { box-sizing: border-box; }
html, body {
  width: 100%;
  height: 100%;
  overflow: hidden;
  touch-action: manipulation;
}
body {
  margin: 0;
  background: var(--bg);
  color: var(--text);
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  display: flex;
  justify-content: center;
  align-items: stretch;
  font-size: 17px;
  overscroll-behavior: none;
}

/* Geräteraum */
.phone {
  width: 100%;
  max-width: 600px;
  height: 100dvh;
  min-height: 100%;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  position: relative;
  margin: 0 auto;
  left: 0;
  right: 0;
}

/* Fixed-state helper (temporär während Keyboard offen) */
.phone--fixed {
  /* styles applied via JS; kept minimal here */
  will-change: transform, top, left;
}

/* Statischer Header */
.app-header {
  background: white;
  height: var(--app-header-height);
  padding: 0 18px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;
  font-weight: 600;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  z-index: 100;
  color: #000000;
  user-select: none;
  flex-shrink: 0;
}
.app-header .ms-logo { position:absolute; left:18px; width:32px; height:32px; display:flex; align-items:center; justify-content:center; }
.app-header .ms-logo img { max-width:100%; max-height:100%; }
.app-header .logo { position:absolute; right:18px; height:40px; }
.app-header .logo img { height:40px; width:auto; }

/* Animierte Bereiche unter Header */
#chatList, #chatWindow {
  position: absolute;
  left: 0; right: 0;
  top: var(--app-header-height);
  bottom: 0;
  transition: transform 0.35s ease, opacity 0.35s ease;
  will-change: transform, opacity;
  background: var(--surface);
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  -webkit-overflow-scrolling: touch;
}

/* Sichtbarkeit */
#chatList.visible { opacity: 1; pointer-events: auto; transform: translateX(0); z-index: 40; }
#chatList.hidden { opacity: 0; pointer-events: none; transform: translateX(-100%); z-index: 0; }
#chatWindow.visible { opacity: 1; pointer-events: auto; transform: translateX(0); z-index: 50; display: flex; }
#chatWindow.hidden { opacity: 0; pointer-events: none; transform: translateX(100%); z-index: 0; display: flex; }

/* Chatliste Items */
#chatList { background: var(--surface); }
.chat-item { display:flex; align-items:center; padding:12px; gap:12px; border-bottom:1px solid var(--border); cursor:pointer; }
.chat-item:hover { background:#2b2b2b; }
.chat-item img { width:52px; height:52px; border-radius:50%; object-fit:cover; background:var(--surface-light); }
.chat-item .info .name { font-size:16px; font-weight:600; }
.chat-item .info .role { font-size:14px; color:var(--text-dim); }

/* Beschreibung */
.desc { background:var(--surface); color:var(--desc-gray); font-size:14px; line-height:1.4; margin:10px 14px; padding:8px; border-radius:8px; white-space:pre-wrap; word-break:break-word; }

/* Chatfenster */
#chatWindow { flex-direction: column; overflow: hidden; }

/* Chat-Header */
.chat-header { background:var(--surface-light); display:flex; align-items:center; padding:10px 14px; border-bottom:1px solid var(--border); z-index:1; flex-shrink:0; }
.back-btn { font-size:23px; cursor:pointer; color:var(--action); margin-right:15px; user-select:none; }
.chat-header img { width:42px; height:42px; border-radius:50%; object-fit:cover; background:var(--surface-light); margin-right:15px; }
.chat-header .name { font-size:16px; font-weight:600; }

/* Nachrichtenbereich */
.messages {
  flex: 1 1 auto;
  overflow-y: auto;
  padding: 10px 14px;
  display:flex;
  flex-direction:column;
  gap:10px;
  scrollbar-width: thin;
  scrollbar-color: var(--accent) transparent;
  scroll-behavior: smooth;
  -webkit-overflow-scrolling: touch;
  overscroll-behavior: contain;
  padding-bottom: calc(var(--composer-height) + 12px); /* reserve space by default */
}
.msg { max-width:75%; padding:10px 14px; border-radius:14px; font-size:15px; line-height:1.4; white-space:pre-wrap; word-break:break-word; color:var(--text); }
.msg.user { background:var(--bubble-user); align-self:flex-end; }
.msg.bot { background:var(--bubble-bot); border:1px solid var(--border); align-self:flex-start; }

/* Inhalte während Übergang unsichtbar halten */
#chatWindow.content-building .desc,
#chatWindow.content-building .messages { opacity:0; pointer-events:none; transition: opacity 0.15s ease; }

/* Composer: default sticky bottom */
.composer {
  background: var(--surface);
  border: none;
  padding: 8px 0;
  display: flex;
  gap: 8px;
  align-items: flex-end;
  flex-shrink: 0;
  position: sticky;
  bottom: 0;
  height: var(--composer-height);
  transform: translateY(-7.5px);
  transition: bottom 0.18s ease, transform 0.18s ease;
  z-index: 60;
}
.composer-inner { display:flex; align-items:flex-end; gap:8px; width:100%; padding-left:14px; padding-right:14px; }
.composer textarea {
  flex:1; min-height:40px; max-height:140px; background:var(--surface); color:var(--text);
  border:1px solid white; border-radius:10px; padding:8px 20px; resize:none; overflow-y:hidden; font-family:inherit;
  font-size:16px; line-height:1.4; height:40px; outline:none;
}
.send-icon { width:40px; height:40px; cursor:pointer; fill:var(--action); flex-shrink:0; user-select:none; transition:filter 0.2s ease; }

/* Composer overlay state (positioned by JS) */
.composer--overlay {
  position: fixed !important;
  left: 0;
  right: 0;
  margin: 0 auto;
  width: 100%;
  max-width: 600px;
  z-index: 120;
  box-shadow: 0 -6px 18px rgba(0,0,0,0.45);
}

/* Pop bubble */
@keyframes bounce { 0%,100%{transform:translateY(0);} 50%{transform:translateY(-6px);} }
.pop-bubble { display:inline-flex; max-width:70%; gap:6px; margin-bottom:10px; align-items:center; white-space:nowrap; }
.pop-dot { width:10px; height:10px; background-color:var(--teams-blue); border-radius:50%; animation:bounce 1.2s infinite ease-in-out; }
.hidden-element { display: none !important; }

@media (max-width:420px) {
  :root { --app-header-height:64px; --composer-height:82px; }
  .chat-item img { width:48px; height:48px; }
}
</style>
</head>
<body>
<div class="phone" id="phone">
  <div class="app-header">
    <div class="ms-logo"><img src="Teams.png" alt="Microsoft Teams Logo"></div>
    <div class="logo"><img src="00_Logo_CWE.png" alt="CWE Logo"></div>
  </div>

  <div id="chatList" class="visible">
    <div class="chat-item" data-person="tina">
      <img src="Tina.png" alt="Tina Müller" />
      <div class="info"><div class="name">Tina Müller</div><div class="role">Finanzabteilung</div></div>
    </div>
    <div class="chat-item" data-person="christian">
      <img src="Christian.png" alt="Christian Weber" />
      <div class="info"><div class="name">Christian Weber</div><div class="role">Marketing</div></div>
    </div>
    <div class="chat-item" data-person="hakan">
      <img src="Hakan.png" alt="Hakan Serdar" />
      <div class="info"><div class="name">Hakan Serdar</div><div class="role">Rechtsabteilung</div></div>
    </div>
    <div class="chat-item" data-person="sophie">
      <img src="Sophie.png" alt="Sophie Fischer" />
      <div class="info"><div class="name">Sophie Fischer</div><div class="role">Personalabteilung</div></div>
    </div>
    <div class="chat-item" data-person="sarah">
      <img src="Sarah.png" alt="Sarah Hosse" />
      <div class="info"><div class="name">Sarah Hosse</div><div class="role">Verkauf</div></div>
    </div>
    <div class="chat-item" data-person="timo">
      <img src="Timo.png" alt="Timo Jung" />
      <div class="info"><div class="name">Timo Jung</div><div class="role">Wirtschaftsanalyse</div></div>
    </div>
    <div class="chat-item" data-person="elke">
      <img src="Elke.png" alt="Elke Wagner" />
      <div class="info"><div class="name">Elke Wagner</div><div class="role">Empfang, Ausbildung & Schule</div></div>
    </div>
  </div>

  <div id="chatWindow" class="hidden content-building" aria-hidden="true">
    <div class="chat-header">
      <span class="back-btn" id="backBtn" role="button" tabindex="0">←</span>
      <img id="chatAvatar" src="" alt="Avatar" />
      <div><div class="name" id="chatName"></div></div>
    </div>

    <div class="desc" id="chatDescription"></div>
    <div class="messages" id="messages" aria-live="polite"></div>

    <div class="composer" id="composer" aria-label="Nachrichtenbereich">
      <div class="composer-inner">
        <textarea id="input" placeholder="Nachricht eingeben..." rows="1" aria-label="Nachricht eingeben"></textarea>
        <svg id="send" class="send-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" aria-label="Senden" role="button" tabindex="0">
          <path d="M2.01 21L23 12 2.01 3v7l15 2-15 2z"/>
        </svg>
      </div>
    </div>
  </div>
</div>

<script>
/* -------------------------
   Baseline app code (messages, open/close, send, etc.)
   ------------------------- */

const phone = document.getElementById('phone');
const profiles = {
  tina: { name: "Tina Müller", avatar: "Tina.png", desc: "Tina arbeitet in der Finanzabteilung und ist dir bei allen Fragestellungen rund um Finanzen behilflich." },
  christian: { name: "Christian Weber", avatar: "Christian.png", desc: "Christian arbeitet in der Marketingabteilung und ist dir bei allen Fragestellungen rund um Marketing behilflich." },
  hakan: { name: "Hakan Serdar", avatar: "Hakan.png", desc: "Hakan arbeitet in der Rechtsabteilung und ist dir bei allen rechtlichen Fragestellungen behilflich." },
  sophie: { name: "Sophie Fischer", avatar: "Sophie.png", desc: "Sophie arbeitet in der Personalabteilung und ist dir bei allen Fragestellungen rund um Personal behilflich." },
  sarah: { name: "Sarah Hosse", avatar: "Sarah.png", desc: "Sarah arbeitet im Verkauf und ist dir bei allen Fragestellungen rund um den Verkauf behilflich." },
  timo: { name: "Timo Jung", avatar: "Timo.png", desc: "Timo arbeitet als Analyst bei der CWE und ist dir bei allen volkswirtschaftlichen Fragestellungen behilflich." },
  elke: { name: "Elke Wagner", avatar: "Elke.png", desc: "Elke arbeitet am Empfang und ist dir bei allen Fragestellungen behilflich, bei denen dir sonst niemand helfen kann. Außerdem ist sie deine Ausbildungskoordinatorin und hilft dir auch bei Fragen rund um die Berufsschule weiter." }
};

const chatList = document.getElementById("chatList");
const chatWindow = document.getElementById("chatWindow");
const messagesDiv = document.getElementById("messages");
const chatDescription = document.getElementById("chatDescription");
const chatName = document.getElementById("chatName");
const chatAvatar = document.getElementById("chatAvatar");
const backBtn = document.getElementById("backBtn");
const input = document.getElementById("input");
const send = document.getElementById("send");
const composer = document.getElementById("composer");

let currentPerson = null;
const history = { tina:[], christian:[], hakan:[], sophie:[], sarah:[], timo:[], elke:[] };
let popBubbleElement = null;

/* Scroll helper */
function scrollToBottom({ smooth = true } = {}) {
  requestAnimationFrame(() => {
    try {
      messagesDiv.scrollTo({ top: messagesDiv.scrollHeight, behavior: smooth ? "smooth" : "auto" });
    } catch (e) {
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }
  });
}

function addMessage(text, who, { scroll = true } = {}) {
  const div = document.createElement("div");
  div.className = "msg " + who;
  div.textContent = text;
  messagesDiv.appendChild(div);
  if (scroll) scrollToBottom();
  return div;
}

function moveChatItemToTop(person) {
  const item = document.querySelector(`.chat-item[data-person="${person}"]`);
  if (item) {
    chatList.removeChild(item);
    chatList.insertBefore(item, chatList.firstChild);
  }
}

/* Open chat */
function hideChatContent() { chatWindow.classList.add('content-building'); }
function showChatContent() { chatWindow.classList.remove('content-building'); }

function openChat(person) {
  currentPerson = person;
  hideChatContent();

  chatWindow.classList.add('hidden');
  chatWindow.classList.remove('visible');
  chatList.classList.remove('hidden');
  chatList.classList.add('visible');

  chatName.textContent = profiles[person].name;
  chatAvatar.src = profiles[person].avatar;

  if (history[person].length === 0) {
    chatDescription.textContent = profiles[person].desc;
    chatDescription.style.display = "block";
  } else {
    chatDescription.style.display = "none";
  }

  messagesDiv.innerHTML = "";
  const prevScrollBehavior = messagesDiv.style.scrollBehavior;
  messagesDiv.style.scrollBehavior = 'auto';
  history[person].forEach(msg => {
    const div = document.createElement("div");
    div.className = "msg " + msg.who;
    div.textContent = msg.text;
    messagesDiv.appendChild(div);
  });
  scrollToBottom({ smooth: false });
  messagesDiv.style.scrollBehavior = prevScrollBehavior || '';

  input.value = "";
  adjustTextareaHeight();

  requestAnimationFrame(() => {
    void chatWindow.offsetHeight;
    chatWindow.classList.remove('hidden');
    chatWindow.classList.add('visible');
    chatWindow.setAttribute('aria-hidden', 'false');

    chatList.classList.remove('visible');
    chatList.classList.add('hidden');

    chatWindow.addEventListener('transitionend', () => showChatContent(), { once: true });
  });
}

function backToChatList() {
  try { if (document.activeElement && typeof document.activeElement.blur === 'function') document.activeElement.blur(); if (input && typeof input.blur === 'function') input.blur(); } catch (e) {}
  hideChatContent();
  chatList.classList.remove('hidden');
  chatList.classList.add('visible');
  chatWindow.classList.remove('visible');
  chatWindow.classList.add('hidden');
  chatWindow.setAttribute('aria-hidden', 'true');
  currentPerson = null;
}

/* textarea auto resize */
function adjustTextareaHeight() {
  input.style.height = "auto";
  const minHeight = 40;
  const maxHeight = 140;
  const scrollHeight = input.scrollHeight;
  if (scrollHeight < minHeight) {
    input.style.height = minHeight + "px";
    input.style.overflowY = "hidden";
  } else if (scrollHeight > maxHeight) {
    input.style.height = maxHeight + "px";
    input.style.overflowY = "scroll";
  } else {
    input.style.height = scrollHeight + "px";
    input.style.overflowY = "hidden";
  }
  let growAmount = scrollHeight - 40;
  if (growAmount < 0) growAmount = 0;
  input.style.marginTop = `-${growAmount}px`;
}

/* pop bubble */
function showPopBubble() {
  if (popBubbleElement) return;
  popBubbleElement = document.createElement("div");
  popBubbleElement.className = "pop-bubble";
  for (let i=0;i<3;i++){ const dot = document.createElement("div"); dot.className="pop-dot"; dot.style.animationDelay=(i*0.2)+"s"; popBubbleElement.appendChild(dot); }
  messagesDiv.appendChild(popBubbleElement);
  scrollToBottom();
}
function removePopBubble() { if (popBubbleElement) { popBubbleElement.remove(); popBubbleElement = null; } }

/* backend payload & send */
function buildMessages() {
  return history[currentPerson].map(m => ({ role: m.who === "user" ? "user" : "assistant", content: m.text }));
}

async function sendMessage() {
  const text = input.value.trim();
  if (!text || !currentPerson) return;
  addMessage(text, "user");
  history[currentPerson].push({ text, who: "user" });

  showPopBubble();
  input.value = "";
  adjustTextareaHeight();
  if (chatDescription.style.display !== "none") chatDescription.style.display = "none";

  try {
    const resp = await fetch("/api/chat", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ person: currentPerson, messages: buildMessages() })
    });
    const data = await resp.json();
    const answer = data.message?.content ?? "Fehler.";
    removePopBubble();
    addMessage(answer, "bot");
    history[currentPerson].push({ text: answer, who: "bot" });
    moveChatItemToTop(currentPerson);
  } catch (error) {
    removePopBubble();
    addMessage("Beim Senden der Nachricht ist ein Fehler aufgetreten.", "bot");
  }
}

/* events */
document.querySelectorAll(".chat-item").forEach(item => item.addEventListener("click", ()=> openChat(item.dataset.person)));
input.addEventListener("keydown", e => {
  if (('ontouchstart' in window) || (navigator.maxTouchPoints > 0)) return;
  if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); sendMessage(); }
});
input.addEventListener("input", () => { adjustTextareaHeight(); });
send.addEventListener("click", sendMessage);
backBtn.addEventListener("click", () => backToChatList());
backBtn.addEventListener("keydown", (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); backToChatList(); } });
messagesDiv.addEventListener("click", () => { if (document.activeElement === input) input.blur(); });
send.addEventListener("keydown", (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); sendMessage(); } });

/* -------------------------
   A2 Enhanced Keyboard Controller
   - keeps UI (phone) visually in place by switching .phone to fixed positioned element
   - composer becomes overlay and is placed above keyboard (bottom = keyboardHeight)
   ------------------------- */

(function keyboardOverlayController() {
  const composerEl = composer;
  const messagesEl = messagesDiv;
  const phoneEl = phone;
  const root = document.documentElement;

  const composerHeightPx = () => composerEl.getBoundingClientRect().height || parseInt(getComputedStyle(root).getPropertyValue('--composer-height')) || 90;

  let overlayActive = false;
  let phoneWasFixed = false;
  let savedPhoneStyles = {};
  let lastKeyboardHeight = 0;
  let visual = window.visualViewport;
  let baselineInnerHeight = window.innerHeight;

  // helper: save inline styles to restore later
  function savePhoneStyles() {
    savedPhoneStyles = {
      position: phoneEl.style.position || '',
      top: phoneEl.style.top || '',
      left: phoneEl.style.left || '',
      width: phoneEl.style.width || '',
      marginLeft: phoneEl.style.marginLeft || '',
      marginRight: phoneEl.style.marginRight || '',
      transform: phoneEl.style.transform || '',
      transition: phoneEl.style.transition || '',
    };
  }
  function restorePhoneStyles() {
    phoneEl.style.position = savedPhoneStyles.position;
    phoneEl.style.top = savedPhoneStyles.top;
    phoneEl.style.left = savedPhoneStyles.left;
    phoneEl.style.width = savedPhoneStyles.width;
    phoneEl.style.marginLeft = savedPhoneStyles.marginLeft;
    phoneEl.style.marginRight = savedPhoneStyles.marginRight;
    phoneEl.style.transform = savedPhoneStyles.transform;
    phoneEl.style.transition = savedPhoneStyles.transition;
    phoneEl.classList.remove('phone--fixed');
  }

  function activatePhoneFixed() {
    if (phoneWasFixed) return;
    // measure current visual position of phone relative to viewport
    const rect = phoneEl.getBoundingClientRect();
    savePhoneStyles();
    // make phone fixed at same visual coordinates
    phoneEl.style.position = 'fixed';
    phoneEl.style.top = rect.top + 'px';
    phoneEl.style.left = rect.left + 'px';
    phoneEl.style.width = rect.width + 'px';
    phoneEl.style.marginLeft = '0';
    phoneEl.style.marginRight = '0';
    phoneEl.style.transform = 'none';
    phoneEl.style.transition = 'none';
    phoneEl.classList.add('phone--fixed');
    phoneWasFixed = true;
  }

  function deactivatePhoneFixed() {
    if (!phoneWasFixed) return;
    restorePhoneStyles();
    phoneWasFixed = false;
  }

  function setComposerOverlay(keyboardHeight) {
    if (!overlayActive) {
      composerEl.classList.add('composer--overlay');
      overlayActive = true;
    }
    const bottomPx = Math.max(0, keyboardHeight);
    composerEl.style.bottom = bottomPx + 'px';
    // Ensure messages have enough padding (composer height + small margin)
    messagesEl.style.paddingBottom = (composerHeightPx() + 12) + 'px';
  }

  function clearComposerOverlay() {
    if (!overlayActive) return;
    composerEl.classList.remove('composer--overlay');
    composerEl.style.bottom = '';
    overlayActive = false;
    // maintain default padding-bottom
    messagesEl.style.paddingBottom = (composerHeightPx() + 12) + 'px';
  }

  function onVisualViewportChange() {
    try {
      if (!visual) return;
      const layoutH = window.innerHeight;
      const visibleTop = visual.offsetTop || 0;
      const visibleH = visual.height || layoutH;
      const visibleBottom = visibleTop + visibleH;
      const keyboardHeight = Math.max(0, Math.round(layoutH - visibleBottom));
      lastKeyboardHeight = keyboardHeight;

      // Heuristik: keyboard wenn > 80px
      if (keyboardHeight > 80) {
        // fix phone to viewport position to avoid browser panning
        activatePhoneFixed();
        setComposerOverlay(keyboardHeight);
      } else {
        // keyboard closed
        clearComposerOverlay();
        // small timeout to let viewport settle, then restore phone
        setTimeout(() => {
          deactivatePhoneFixed();
        }, 40);
      }
    } catch (err) {
      console.error(err);
    }
  }

  // Fallback using window.innerHeight changes (Android browsers)
  function onResizeFallback() {
    const newInner = window.innerHeight;
    const diff = Math.max(0, baselineInnerHeight - newInner);
    // conservative thresholds
    if (diff > 120) {
      lastKeyboardHeight = diff;
      activatePhoneFixed();
      setComposerOverlay(diff);
    } else {
      // maybe closed
      if (overlayActive || phoneWasFixed) {
        clearComposerOverlay();
        setTimeout(() => {
          deactivatePhoneFixed();
        }, 40);
      }
      // update baseline (e.g. orientation change)
      baselineInnerHeight = newInner;
    }
  }

  // initialize padding bottom to composer height (keeps last messages visible)
  messagesEl.style.paddingBottom = (composerHeightPx() + 12) + 'px';

  // attach listeners
  if (visual) {
    visual.addEventListener('resize', onVisualViewportChange, { passive: true });
    visual.addEventListener('scroll', onVisualViewportChange, { passive: true });
    // initial check
    onVisualViewportChange();
  }

  window.addEventListener('resize', () => {
    if (window.visualViewport) {
      // let visualViewport handler run; ensure fallback after tiny delay
      setTimeout(onVisualViewportChange, 60);
      return;
    }
    onResizeFallback();
  }, { passive: true });

  // Focus/blur handlers on input to help with timing
  input.addEventListener('focus', () => {
    setTimeout(() => {
      if (window.visualViewport) onVisualViewportChange();
      else {
        const diff = Math.max(0, baselineInnerHeight - window.innerHeight);
        if (diff > 80) {
          activatePhoneFixed();
          setComposerOverlay(diff);
        } else {
          // best-effort overlay (typical keyboard height fallback)
          activatePhoneFixed();
          setComposerOverlay(Math.min(450, Math.max(200, diff || 300)));
        }
      }
    }, 60);
  }, { passive: true });

  input.addEventListener('blur', () => {
    setTimeout(() => {
      if (window.visualViewport) onVisualViewportChange();
      else {
        clearComposerOverlay();
        setTimeout(() => { deactivatePhoneFixed(); }, 80);
      }
    }, 150);
  }, { passive: true });

  // orientation change: reset baseline and recalc
  window.addEventListener('orientationchange', () => {
    setTimeout(() => {
      baselineInnerHeight = window.innerHeight;
      if (window.visualViewport) onVisualViewportChange();
    }, 300);
  });

  // keep messages padding synced if composer size changes
  new ResizeObserver(() => {
    messagesEl.style.paddingBottom = (composerHeightPx() + 12) + 'px';
  }).observe(composerEl);

  // expose for debugging if desired
  window.__keyboardController = {
    get lastKeyboardHeight() { return lastKeyboardHeight; },
    isOverlayActive: () => overlayActive,
    forceOverlay: (px) => { activatePhoneFixed(); setComposerOverlay(px); }
  };
})();

/* -------------------------
   Swipe gestures (unchanged)
   ------------------------- */

let touchStartX = null, touchStartY = null, touchMoveX = null, touchMoveY = null, dragging = false;

chatWindow.addEventListener('touchstart', function(e) {
  if (e.touches.length === 1) {
    touchStartX = e.touches[0].clientX; touchStartY = e.touches[0].clientY;
    touchMoveX = null; touchMoveY = null; dragging = false;
  }
}, {passive: true});

chatWindow.addEventListener('touchmove', function(e) {
  if (e.touches.length === 1 && touchStartX !== null && touchStartY !== null) {
    touchMoveX = e.touches[0].clientX; touchMoveY = e.touches[0].clientY;
    const deltaX = touchMoveX - touchStartX; const deltaY = touchMoveY - touchStartY;
    const absDeltaX = Math.abs(deltaX); const absDeltaY = Math.abs(deltaY);
    const swipeStartedLeftArea = touchStartX < 100;
    if (swipeStartedLeftArea && deltaX > 0 && absDeltaX > absDeltaY) {
      dragging = true;
      hideChatContent();
      e.preventDefault && e.preventDefault();
      chatWindow.style.transition = 'none';
      chatList.style.transition = 'none';
      chatList.classList.remove('hidden'); chatList.classList.add('visible');
      chatList.style.pointerEvents = 'auto';
      const translateX = Math.min(window.innerWidth, deltaX);
      chatWindow.style.transform = `translateX(${translateX}px)`;
      const pct = Math.min(1, deltaX / window.innerWidth);
      const listTranslate = -100 + (pct * 100);
      chatList.style.transform = `translateX(${listTranslate}%)`;
    }
  }
}, {passive: false});

chatWindow.addEventListener('touchend', function(e) {
  if (touchStartX !== null && touchMoveX !== null && touchStartY !== null && touchMoveY !== null) {
    const deltaX = touchMoveX - touchStartX; const deltaY = touchMoveY - touchStartY;
    const absDeltaX = Math.abs(deltaX); const absDeltaY = Math.abs(deltaY);
    const swipeStartedLeftArea = touchStartX < 100;
    if (dragging && swipeStartedLeftArea && deltaX > 50 && absDeltaX > absDeltaY) {
      try { if (document.activeElement && typeof document.activeElement.blur === 'function') document.activeElement.blur(); if (input && typeof input.blur === 'function') input.blur(); } catch (e) {}
      hideChatContent();
      chatWindow.style.transition = '';
      chatList.style.transition = '';
      chatWindow.style.transform = `translateX(${window.innerWidth}px)`;
      chatList.style.transform = `translateX(0%)`;
      const cleanup = () => {
        chatWindow.style.transition = '';
        chatWindow.style.transform = '';
        chatList.style.transform = '';
        chatList.style.pointerEvents = '';
        chatWindow.classList.remove('visible');
        chatWindow.classList.add('hidden');
        chatWindow.setAttribute('aria-hidden', 'true');
        chatWindow.removeEventListener('transitionend', cleanup);
      };
      chatWindow.addEventListener('transitionend', cleanup);
      chatList.classList.remove('hidden'); chatList.classList.add('visible');
      currentPerson = null;
    } else {
      chatWindow.style.transition = '';
      chatList.style.transition = '';
      chatWindow.style.transform = '';
      chatList.style.transform = '';
      if (!chatWindow.classList.contains('hidden')) {
        chatWindow.classList.add('visible'); chatWindow.classList.remove('hidden');
      }
      chatList.classList.remove('visible'); chatList.classList.add('hidden');
      chatList.style.pointerEvents = '';
      showChatContent();
    }
  }
  touchStartX = null; touchStartY = null; touchMoveX = null; touchMoveY = null; dragging = false;
}, {passive: true});

/* keep messages padding synced on load and composer resize */
function syncComposerPadding() {
  messagesDiv.style.paddingBottom = (composer.getBoundingClientRect().height + 12) + 'px';
}
window.addEventListener('load', syncComposerPadding, { passive: true });
new ResizeObserver(syncComposerPadding).observe(composer);

/* End script */
</script>
</body>
</html>
